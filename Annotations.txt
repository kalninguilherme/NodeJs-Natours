// const { MongoClient, ServerApiVersion } = require('mongodb');
// const uri = 'mongodb+srv://Kalnin:KF6wPJqSXDrUwOnV@cluster0.ackdn4v.mongodb.net/?retryWrites=true&w=majority';
// // Create a MongoClient with a MongoClientOptions object to set the Stable API version
// const client = new MongoClient(uri, {
//   serverApi: {
//     version: ServerApiVersion.v1,
//     strict: true,
//     deprecationErrors: true,
//   },
// });
// async function run() {
//   try {
//     // Connect the client to the server	(optional starting in v4.7)
//     await client.connect();
//     // Send a ping to confirm a successful connection
//     await client.db('admin').command({ ping: 1 });
//     console.log('Pinged your deployment. You successfully connected to MongoDB!');
//   } finally {
//     // Ensures that the client will close when you finish/error
//     await client.close();
//   }
// }
// run().catch(console.dir);

// { difficulty: 'easy', duration: {$gte: 5}} // Query for mongoDB

      // sort('price ratingAverage') // Mongoose sort
      // Minus reverse the sort on MongoDb

      //const tours = JSON.parse(fs.readFileSync(`${__dirname}/../dev-data/data/tours-simple.json`));


// // 1A) Filtering
    // const queryObj = { ...req.query }; // Create a copy with all key values pairs
    // const excludedFields = ['page', 'sort', 'limit', 'fields'];
    // excludedFields.forEach((el) => delete queryObj[el]);

    // // 1B) Advanced Filtering
    // let queryStr = JSON.stringify(queryObj);
    // queryStr = queryStr.replace(/\b(gte|gt|lte|lt)\b/g, (match) => `$${match}`); // Regex

    // let query = Tour.find(JSON.parse(queryStr));

    // 2) Sorting
    // if (req.query.sort) {
    //   const sortBy = req.query.sort.split(',').join(' ');
    //   query = query.sort(sortBy);
    // } else {
    //   query = query.sort('-createdAt');
    // }

    // 3) Field limiting
    // if (req.query.fields) {
    //   const fields = req.query.fields.split(',').join(' ');
    //   query = query.select(fields); // Projecting
    // } else {
    //   query = query.select('-__v');
    // }

    // 4) Pagination

    // if (req.query.page || req.query.limit) {
    //   const page = req.query.page * 1 || 1; // Defining default values
    //   const limit = req.query.limit * 1 || 5;
    //   const skip = (page - 1) * limit;

    //   const numTours = await Tour.countDocuments();
    //   if (skip >= numTours) throw new Error('This page does not exist');

    //   // page=3&limit=10, 1-10 page 1, 11-20 page2, 21-30 page3
    //   query = query.skip(skip).limit(limit);
    // } else {
    //   query = query.limit(5);
    // }

// const query = Tour.find().where('duration').equals(5).where('difficulty').equals('easy');

    // If you don't specify a parameter, it brings all items and transform in Json

    // // You can have many Middlewares(hooks) for the same structure
// tourSchema.pre('save', function (next) {
//   console.log('Will save document...');
//   next();
// });

// // Hapenas after all the pre Middleware runs
// tourSchema.post('save', function (doc, next) {
//   console.log(doc);
//   next();
// });

app.use((req, res, next) => {
  console.log('Hello from the Middleware!');
  next();
});

// res.status(404).json({
  //   status: 'fail',
  //   message: `Can't find ${req.originalUrl} on the server`,
  // });

    // const newTour = newTour({})
    // newTour.save()

    exports.getTour = async (req, res, next) => {
  try {
    const tour = await Tour.findById(req.params.id);
    if (!tour) {
      return next(new AppError('No tour found', 400));
    }

    res.status(200).json({
      status: 'success',
      data: {
        tour,
      },
    });
  } catch (error) {
    return next(error);
  }
};

// async function connect() {
//   try {
//     await mongoose.connect(DB);
//     console.log('Connected to MongoDB');
//   } catch (error) {
//     console.error(error);
//   }
// }
// connect();

//let error = { ...err };
    //let error = Object.assign(err);

    // if (err.name === 'CastError') {
    //   error = handleCastErrorDB(error);
    // }



    const { v4: uuidv4 } = require('uuid');
const crypto = require('crypto');
const aberrant = uuidv4();
console.log(aberrant);

const a = crypto.createHash('sha256').update(aberrant).digest('hex');
console.log(a);
const b = crypto.createHash('sha256').update('64ab68e6-f3b6-44b1-9be5-aa37436c87a9').digest('hex');
console.log(b);

// router
//   .route('/:tourId/reviews')
//   .post(authController.protect, authController.restrictTo('user'), reviewController.createReview);

// Post /tour/234fad/reviews -> nested route
// Get /tour/234fad/reviews -> nested route
// Get /tour/234fad/reviews/9435fdas -> nested route

 if (!isValidObjectId(req.params.id)) {
      return next(new AppError('Invalid Parameters', 400));
    }

    // exports.deleteTour = catchAsync(async (req, res, next) => {
//   if (!isValidObjectId(req.params.id)) {
//     return next(new AppError('Invalid Tour', 400));
//   }
//   const tour = await Tour.findByIdAndDelete(req.params.id);
//   if (!tour) {
//     return next(new AppError('No tour found with the ID provided', 400));
//   }
//   res.status(204).json({
//     status: 'sucess',
//     data: null,
//   });
// });

const { isValidObjectId } = require('mongoose');

  // this.populate({
  //   path: 'tour',
  //   select: 'name',
  // }).populate({
  //   path: 'user',
  //   select: 'name photo',
  // });

// On post the "query" is already executed, so you don't have access to the query data

  // reviewSchema.pre(/^findOneAnd/, async function (next) {
//   this.r = await this.findOne();
//   // console.log(this.r);
//   next();
// });

